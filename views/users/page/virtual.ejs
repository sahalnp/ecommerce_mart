<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual Watch Try-On Example</title>
  <style>
    body, html {
      margin: 0;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      font-family: Arial, sans-serif;
    }
    
    video, canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scaleX(-1);
    }
    
    .controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      max-width: 220px;
    }
    
    .size-control {
      margin: 10px 0;
    }
    
    .back-button {
      margin-top: 20px;
      padding: 8px 16px;
      background-color: #6b5fe9;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .back-button:hover {
      background-color: #333;
    }
 
    input[type="range"] {
      width: 150px;
    }

    .status {
      margin: 10px 0;
      padding: 5px;
      border-radius: 4px;
      font-size: 12px;
    }

    .status.success {
      background-color: rgba(0, 255, 0, 0.2);
      color: #00ff00;
    }

    .status.error {
      background-color: rgba(255, 0, 0, 0.2);
      color: #ff6666;
    }

    .message {
      margin-top: 10px;
      font-weight: bold;
      font-size: 14px;
      min-height: 18px;
      padding: 8px;
      border-radius: 6px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .message.show-hand {
      background-color: rgba(255, 165, 0, 0.2);
      color: #ffa500;
      border: 1px solid #ffa500;
    }

    .message.hand-detected {
      background-color: rgba(0, 255, 0, 0.2);
      color: #00ff00;
      border: 1px solid #00ff00;
    }

    .message.hand-straight {
      background-color: rgba(0, 255, 255, 0.2);
      color: #00ffff;
      border: 1px solid #00ffff;
    }
  </style>
</head>
<body>
  <div class="controls">
    <h3>Watch Controls</h3>
    
    <div id="status" class="status"></div>
    
    <div class="size-control">
      <label>Size: <span id="sizeValue">120</span>px</label>
      <input type="range" id="sizeSlider" min="20" max="200" value="120">
    </div>
    
    <div class="size-control">
      <label>Y Offset: <span id="offsetValue">10</span>px</label>
      <input type="range" id="offsetSlider" min="-30" max="50" value="10">
    </div>

    <div class="size-control">
      <label>X Offset: <span id="xOffsetValue">0</span>px</label>
      <input type="range" id="xOffsetSlider" min="-50" max="50" value="0" />
    </div>

    <div class="message show-hand" id="handMessage">Show your hand straight to the camera</div>
    
    <button onclick="history.back()" class="back-button">← Back</button>
  </div>

  <video id="webcam" autoplay playsinline width="640" height="480"></video>
  <canvas id="overlay" width="640" height="480"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('overlay');
    const canvasCtx = canvasElement.getContext('2d');
    
    // Controls
    const sizeSlider = document.getElementById('sizeSlider');
    const offsetSlider = document.getElementById('offsetSlider');
    const xOffsetSlider = document.getElementById('xOffsetSlider');
    const sizeValue = document.getElementById('sizeValue');
    const offsetValue = document.getElementById('offsetValue');
    const xOffsetValue = document.getElementById('xOffsetValue');
    const status = document.getElementById('status');
    const handMessage = document.getElementById('handMessage');
    
    let watchSize = 120;
    let yOffset = 10;
    let xOffset = 0;
    
    sizeSlider.addEventListener('input', (e) => {
      watchSize = parseInt(e.target.value);
      sizeValue.textContent = watchSize;
    });
    
    offsetSlider.addEventListener('input', (e) => {
      yOffset = parseInt(e.target.value);
      offsetValue.textContent = yOffset;
    });

    xOffsetSlider.addEventListener('input', (e) => {
      xOffset = parseInt(e.target.value);
      xOffsetValue.textContent = xOffset;
    });

    // Create a default sample watch image
    function createSampleWatchImage() {
      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 200;
      const ctx = canvas.getContext('2d');
      
      // Draw watch face (outer circle)
      ctx.beginPath();
      ctx.arc(100, 100, 80, 0, 2 * Math.PI);
      ctx.fillStyle = '#c9b037'; // Gold color
      ctx.fill();
      ctx.strokeStyle = '#b8860b';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Draw watch face (inner circle)
      ctx.beginPath();
      ctx.arc(100, 100, 70, 0, 2 * Math.PI);
      ctx.fillStyle = '#1a1a1a';
      ctx.fill();
      
      // Draw hour markers
      for (let i = 0; i < 12; i++) {
        const angle = (i * 30) * Math.PI / 180;
        const x1 = 100 + Math.cos(angle - Math.PI/2) * 60;
        const y1 = 100 + Math.sin(angle - Math.PI/2) * 60;
        const x2 = 100 + Math.cos(angle - Math.PI/2) * 50;
        const y2 = 100 + Math.sin(angle - Math.PI/2) * 50;
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#ecf0f1';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Draw hour hand (pointing to 2)
      const hourAngle = (2 * 30) * Math.PI / 180 - Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(100, 100);
      ctx.lineTo(100 + Math.cos(hourAngle) * 35, 100 + Math.sin(hourAngle) * 35);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.stroke();
      
      // Draw minute hand (pointing to 10)
      const minuteAngle = (10 * 6) * Math.PI / 180 - Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(100, 100);
      ctx.lineTo(100 + Math.cos(minuteAngle) * 50, 100 + Math.sin(minuteAngle) * 50);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.stroke();
      
      // Draw center dot
      ctx.beginPath();
      ctx.arc(100, 100, 6, 0, 2 * Math.PI);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      
      // Draw watch band parts
      ctx.fillStyle = '#c9b037';
      ctx.fillRect(85, 20, 30, 40); // top band
      ctx.fillRect(85, 140, 30, 40); // bottom band
      
      return canvas;
    }

    // Initialize with default watch image
    let productImg = new Image();
    productImg.src = "<%= product.image[7].filepath %>"; 
    
  
    
    productImg.onerror = () => {
      status.textContent = 'Error loading watch image';
      status.className = 'status error';
    };

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // Mirror the canvas horizontally
      canvasCtx.scale(-1, 1);
      canvasCtx.translate(-canvasElement.width, 0);

      // Draw webcam frame
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0 && productImg) {
        const landmarks = results.multiHandLandmarks[0];
        
        // Get wrist position (landmark 0)
        const wrist = landmarks[0];
        const wristX = wrist.x * canvasElement.width;
        const wristY = wrist.y * canvasElement.height;

        // Calculate hand orientation for better watch placement
        const middleFinger = landmarks[9]; // Middle finger MCP
        const handAngle = Math.atan2(
          middleFinger.y - wrist.y,
          middleFinger.x - wrist.x
        );

        // Draw watch image with rotation based on hand orientation
        canvasCtx.save();
        canvasCtx.translate(wristX + xOffset, wristY + yOffset);
        canvasCtx.rotate(handAngle + Math.PI/2);
        
        const imgW = watchSize;
        const imgH = watchSize;
        
        canvasCtx.globalAlpha = 0.9;
        canvasCtx.drawImage(productImg, -imgW / 2, -imgH / 2, imgW, imgH);
        canvasCtx.restore();

        // Detect if hand is "straight"
        // We'll say straight if angle is close to 0 or ±π (within ~20 degrees)
        const angleDegrees = handAngle * (180 / Math.PI);
        const straightThreshold = 20;

        // Normalize angle between -180 and 180
        const normalizedAngle = ((angleDegrees + 180) % 360) - 180;

        if (Math.abs(normalizedAngle) < straightThreshold || Math.abs(normalizedAngle - 180) < straightThreshold || Math.abs(normalizedAngle + 180) < straightThreshold) {
          handMessage.textContent = "Perfect! Hand is straight ✓";
          handMessage.className = 'message hand-straight';
        } else {
          handMessage.textContent = "Hand detected - Keep it straight";
          handMessage.className = 'message hand-detected';
        }

      } else {
        // No hand detected
        handMessage.textContent = "Show your hand straight to the camera";
        handMessage.className = 'message show-hand';
      }

      canvasCtx.restore();
    }

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
      },
      width: 640,
      height: 480
    });
    camera.start();
  </script>
</body>
</html>